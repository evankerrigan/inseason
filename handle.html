<html>
  <head>
    <title>Spline Editor</title>
    <script type="text/javascript" src="js/lib/protovis.min.js"></script>
    <style type="text/css">

#fig {
  width: 420px;
  height: 420px;
}

.header {
  float: right;
  padding-top: 5px;
}

    </style>
  </head>
  <body><div id="center"><div id="fig">
    <script type="text/javascript+protovis">

// These vars are required for the handle to work
var w = 400,
    h = 400,
    xCenter = w / 2,
    yCenter = h / 2,
    radius = 160,
    initAngle = -(Math.PI / 2);

// New PV behavior that will translate mouse position onto a circle
pv.Behavior.dragCircle = function() {
    var scene, // scene context
        index, // scene context
        p, // particle being dragged
        v1, // initial mouse-particle offset
        max;

    /** @private */
    function mousedown(d) {
        index = this.index;
        scene = this.scene;
        var m = this.mouse();
        v1 = ((p = d).fix = pv.vector(d.x, d.y)).minus(m);
        max = {
            x: this.parent.width() - (d.dx || 0),
            y: this.parent.height() - (d.dy || 0)
        };
        scene.mark.context(scene, index, function() { this.render(); });
        pv.Mark.dispatch("dragstart", scene, index);
    }

    /** @private */
    function mousemove() {
        if (!scene) return;
        scene.mark.context(scene, index, function() {
            var m = this.mouse();
            // [LNF] p0 is the origin of the viz
            var p0 = {
                x: xCenter,
                y: yCenter 
            };
            // [LNF] Calc the angle between the mouse and the origin
            p.theta = Math.atan2(m.y - p0.y, m.x - p0.x);
            // [LNF] Translate the angle into cartesian coordinates, scaled to the center
            p.x = p.fix.x = (Math.cos(p.theta) * radius) + xCenter;
            p.y = p.fix.y = (Math.sin(p.theta) * radius) + yCenter;
            this.render();
        });
        pv.Mark.dispatch("drag", scene, index);
    }

    /** @private */
    function mouseup() {
        if (!scene) return;
        p.fix = null;
        scene.mark.context(scene, index, function() { this.render(); });
        pv.Mark.dispatch("dragend", scene, index);
        scene = null;
    }

    pv.listen(window, "mousemove", mousemove);
    pv.listen(window, "mouseup", mouseup);
    return mousedown;
};

function getCurrentAngle() {
    return handle[1].theta;
}

// This maps each month segment to a set of angles
var monthAngles = [
    {
        month: 1,
        startAngle: -(Math.PI / 2),
        endAngle: -(Math.PI / 3)
    },
    {
        month: 2,
        startAngle: -(Math.PI / 3),
        endAngle: -(Math.PI / 6)
    },
    {
        month: 3,
        startAngle: -(Math.PI / 6),
        endAngle: 0
    },
    {
        month: 4,
        startAngle: 0,
        endAngle: (Math.PI / 6)
    },
    {
        month: 5,
        startAngle: (Math.PI / 6),
        endAngle: (Math.PI / 3)
    },
    {
        month: 6,
        startAngle: (Math.PI / 3),
        endAngle: (Math.PI / 2)
    },
    {
        month: 7,
        startAngle: (Math.PI / 2),
        endAngle: (2 * Math.PI / 3)
    },
    {
        month: 8,
        startAngle: (2 * Math.PI / 3),
        endAngle: (5 * Math.PI / 6)
    },
    {
        month: 9,
        startAngle: (5 * Math.PI / 6),
        endAngle: Math.PI
    },
    {
        month: 10,
        startAngle: -Math.PI,
        endAngle: -(5 * Math.PI / 6)
    },
    {
        month: 11,
        startAngle: -(5 * Math.PI / 6),
        endAngle: -(2 * Math.PI / 3)
    },
    {
        month: 12,
        startAngle: -(2 * Math.PI / 3),
        endAngle: -(Math.PI / 2)
    }
];

// Gets the month that the handle is currently resting on
function getSelectedMonth() {
    var theta = getCurrentAngle();
    for (m in monthAngles)
        if (theta >= monthAngles[m].startAngle &&
            theta <= monthAngles[m].endAngle)
            return monthAngles[m].month;
}

// The actual handle itself
var handle = [
    // Center
    {
        x: xCenter,
        y: yCenter,
        origin: true
    },
    // Handle
    {
        // Default the handle location to initAngle
        x: (Math.cos(initAngle) * radius) + xCenter,
        y: (Math.sin(initAngle) * radius) + yCenter,
        theta: initAngle
    }
];

var vis = new pv.Panel()
    .width(w)
    .height(h)
    .fillStyle("#fff")
    .strokeStyle("#ccc")
    .lineWidth(4)
    .antialias(false)
    .margin(2);

vis.add(pv.Dot)
    .data([{ x: w / 2, y: h / 2 }])
    .left(function(d) d.x)
    .top(function(d) d.y)
    .radius(radius)
    .strokeStyle("#fbb")
    .fillStyle("#fff")
    .lineWidth(12);

// Handle line
vis.add(pv.Line)
    .data(function() handle)
    .left(function(d) d.x)
    .top(function(d) d.y)
    .interpolate("linear")
    .segmented(false)
    .strokeStyle("#000")
    .lineWidth(2);

// Handle dot
vis.add(pv.Dot)
    .data(function() handle)
    .left(function(d) d.x)
    .top(function(d) d.y)
    .radius(7)
    .cursor(function(d) d.origin == true ? "" : "move")
    .strokeStyle(function(d) d.origin == true ? null : "#000")
    .fillStyle(function(d) d.origin == true ? null : this.strokeStyle().alpha(.4))
    .event("mousedown", pv.Behavior.dragCircle())
    .event("dragstart", null)
    .event("drag", vis);

vis.render();

pv.listen(window, "mousedown", function() self.focus());

    </script>
  </div></div></body>
</html>